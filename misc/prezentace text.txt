Přečti tohle:

Visitor pattern je jeden z návrhových vzorů podle Gang of Four.

Hlavní motivace za visitor patternem je možnost objektům jednoduše přidávat nové funkce beze změny jejich struktury. Struktura třídy tedy zůstává a její nová funkcionalita je umístěna jinde.

Motivaci si ukážeme na následujícím příkladu.

Snažil jsem se vybrat téma, na které se visitor pattern dá použít a na kterém ho snad ještě nikdo neprezentoval.

<< OBRAZOVKA PATREON, DEFINICE A ODKAZ NA WIKI A PATREON>>

Dle wikipedie je Patreon platforma, která umožnuje fanouškům platit tvůrcům za jejich práci. Tvůrci jsou běžně vývojáři, youtubeři, moderátoři, a tak dál. 

Fanoušci tak dokáží zajistit tvůrcům stálý příjem a ti jim na oplátku dávají prémiový obsah, který pro ostatní není dostupný. 

Tvůrci mívají různé výše příspěvku, podle kterého se odvíjí množství dostupných výhod.

Rozdělení do úrovní se téměř nemění, výhody mohou v průběhu času přibývat.

V tomto příkladě tedy půjde o interakci patronů a výhod, které dostávají. 

<< OBRAZOVKA, KDE JE PATRON INTERFACE>>	

Mějme nějaký interface, který reprezentuje patrony.

Jako metody patron interfacu jsou služby, které tvůrce patronům nabízí. Tento umělec jim pro začátek třeba do schránky na patreon účtu pošle záznam z koncertu nebo jim přidá nějaké featury do chatu na streamu - pro příklad nové emotikony. 

<< PATRON INTERFACE DIAGRAM  >>

Konkrétní implementace dědí tuto strukturu, ale platí, že každá funkce dělá něco jiného. V tomto případě více příspívající patroni dostanou lepší obsah.

V tomto příkladu dělím patrony do tří úrovní podle výše jejich příspěvků. Můžete si představit, že úroveň 0 odpovídá dvěma dolarům měsíčně, úroveň 1 pěti a úroveň 2 deseti.

Umělec může mít připraveno kolik úrovní chce, často však počet úrovní nemění.

<< IMPLEMENTACE TIERU 0, TIER 1, TIER 2>>

Konkrétní implementace patrona už je třída, která dědí od třídy person všemožné lidské vlastnosti a navíc implementuje patron interface s patřičnými metodami.

Všimněte si různých těl u funkcí.

<< NEE -- nechme tu samou obrazovku OBRAZOVKA TIER 4 S IMPLEMENTOVANYMI METODAMI>>

<< DIAGRAM PRIDAN tier N+1>>

Rozhodne-li se tvůrce, že přidá novou úroveň fanoušků, bude muset naprogramovat nová těla interfacových metod pro právě jednu třídu.


<< DIAGRAM PRIDANE FUNKCE DO INTERFACE>>

Naopak když se rozhodne, že dá fanouškům navíc ještě další výhodu tedy funkci, a upraví patronský interface, bude muset zasáhnout do každé konkrétní patronské třídy. 

Nový kód je tak roztříštěný po různých souborech.

Navíc metody, které přidáváme dané třídě pro ní nemusí být vhodné, protože s danou třídou nemusí nijak souviset.

<< OBRAZOVKA S DIAGRAMEM VISITOR>>

Visitor pattern je graficky zobrazen na tomto diagramu.

Zde vidíme visitor interface, který deklaruje metodu visit pro každý konkrétní element - podle našeho příkladu tedy pro každou úroveň podpory od fanouška. Všechny konkrétní implementace tohoto interfacu odpovídají jedné konkrétní funkcionalitě. Visitor 1 je featura do chatu, visitor 2 je fakturační formulář.

Metoda visit může mít navíc jak návratovou hodnotu, tak může brát více parametrů než jen odkaz na prvek. Bude to řešeno buď polem parametrů, nebo se vytipují specifické prvky, od kterých budeme nějaké ifnormace očekávat.

Výhoda více parametrů je ta, že o sobě element může předat další informace, například o svém vnitřním stavu. Kdyby nebylo pole s dalšími parametry, musely by být ty informace dostupné přes veřejné funkce, což narušuje zapouzdření tříd.


<< DIAGRAM ACCEPTOR>>

Tady je akceptující interface - gang of four to označuje jako element nebo abstrakt element. Má metodu accept, která přijímá implementaci visitor interfacu. Konkrétní elementy jistě mohou mít i jiné metody, v tomto není návrhový vzor nijak omezující. 

Každopádně vždy implementace metody accept obsahuje vždy řádek, na kterém je volání funkce visit na předaném visitoru v s parametrem this. Pro další parametry platí to, co jsem říkal na předchozím slajdu.

<< OBRAZOVKA, KDE JE TO ROZEPSANO >>

Na tomto slajdu je vidět, o čem jsem jsem mluvil.

Máme dva hlavní stavební kameny. Visitor interface, který deklaruje metodu visit pro každý konkrétní element, a interface pro prvky, které budou visitor využívat, abstract element. Ty mají metodu accept.

Metoda accept přijímá jako argument implementaci třídy visitor, na kterém volá příslušnou metodu visit

Ještě jednou připomínám, metoda visit může přijímat více než jeden argument a může mít i návratovou hodnotu.

<< KDE VISITOR PATTERN VYUZIVAME>>

Visitor pattern se hodí použít tehdy, když plánujeme přidávat třídám nové funkce nebo na nich provádět nové operace.

Když těchto operací bude mnoho a nebudou přímo souviset s konkrétními třídami, jako třeba přepis do dokumentové formy, tak se použitím visitoru tyto operace oddělí od tříd a kód tak nebude rozesetý po různých souborech. Navíc se související funkce budou nacházet ve stejných visitorech.

Hlavní, co je důležité při použití visitor patternu je to, aby se struktura tříd měnila jen vzácně. Každá nová třída, která by měla visitory používat, znamená úpravu všech existujících visitorů.


<< CO TO ZNAMENA, KDYZ HO VYUZIJEME>>

Využití visitor patternu přínáší pozitiva i negativa. 

Mezi pozitivní věci patři to, že je jednoduché přidání nové funkcionality

Operace, které spolu souvisí jsou na jednom místě, v jednom visitoru a jsou naopak odděleny od nesouvisejících operací.

To navíc znamená, že jsou do visitorů umístěny algoritmy operací i datové struktury pro ně potřebné.

Negativními vlastnostmi je to, že je náročné přidat nové prvky. Musíme při tom upravit všechny visitory.

Také je potřeba si předem rozmyslet, jaké struktury budou využívány, aby se nenarazilo na předchozí problém

Další nevýhodou je narušení zapouzdření, o tom jsem již mluvil.

<< OBRAZOVKA PATREON VISITOR a PATRON INTERFACE >>

Teď si ukážeme visitor pattern nasazený na příklad s patreonem.

Definoval jsem si dva interfacy, jeden se jmenuje patron interface, druhý patron visitor.

Patron visitor je interface, který budou implementovat konkrétní visitory a definuje 3 metody visit, každou pro jednu patronskou úroveň. V komentáři je vidět, že se metody mohou jmenovat pouze visit, rozdílné jsou v parametru, který očekávají.

V příkladu volím verzi, kde je v názvu explicitně označeno, ke které třídě metoda visit patří. 

Patron interface budou opět implementovat 3 třídy, patroni nulté, první a druhé úrovně. Narozdíl od minulého příkladu má patron interface pouze jednu metodu a to accept, která přijímá patron visitora. Výhody pro fanoušky už budou v podobě visitorů.

<< PATRON urovne implementace >>

Tady vidíme, jak konkrétní třídy vypadají. Úroveň 2 si můžete domyslet. Na visitoru se volá příslušná metoda visit pro danou třídu. 

Teď si ukážeme, jak vypadají konkrétní visitory.

<< KONKRETNI IMPLEMENTACE visitorů >>

Vlevo vidíme visitora, který konkrétním implementacím patronů přidělí nové featury do chatu. Vpravo je zase visitor, který pošle fanouškům nějaké dárečky k jejich narozeninám.

Visitor může dělat i složitější úkony než jen vypisovat na konzoli.

Proto musí mít třídy, na které se visitor volá, nějaký mechanismus, jak o sobě visitoru předat informaci. Musí tedy mít public metody nebo fieldy, na které si visitor sáhne a dostane tak o třídách informace potřebné k provedení nějaké složitější operace.

Přidání nového visitoru je jednoduché. Každé třídě příslusná implementace metody visit.

<< RUN PROGRAM >>

Vytvoříme si program, kde máme nějaké patrony všech možných úrovní a k tomu si vytvoříme patron visitora. 

Teď to bude live stream visitor, a necháme ho navštívit všechny patrony.

<< OBRAZOVKA S VYPISEM >>

Tady vidíme výpis. Použily se správné metody.

<< ZMENA VISITORA >>

Když vyměníme konkrétní visitory, bude to fungovat taky.

<< JINY VYPIS>>

Tady opět vidíme výpis.

K tomhule poznámka. Ne vždy musí visitor obejít všechny elementy. Zrovna u těch narozenin je to dobrý příklad, ty většinou nemají všichni naráz.  



<< OBRAZOVKA S DispatchingEM - single double definice>>

S visitor patternem se váže něco, čemu se říká double dispatch

Nejdříve povím, co je to dynamic dispatch, single a double dispatch.

Dynamic dispatch je proces, při kterém se vybere správná implementace polymorfické operace, která se má zavolat za run timu.

Pak je ještě static dispatch, při něm se funkce vybere již za překladu.

Objektově orientované jazyky, které běžně používáme, podporují takzvaný single dispatch. Volaná funkce se vybere podle jména a typu objektu, na kterém se volá. 

Při multiple dispatch se vybere funkce podle jména a typu více objektů.

Double dispatch je speciální případ multiple dispatche.

Nejlépe to jde vidět na příkladu.

<< SINGLE DISPATCH obrazek s kodem, polak a cech>>

Tady máme třídu person, která je base třídou pro třídu čecha a poláka. Ty overridují metodu speak následovně.

<< runner SINGLE DISPATCH>>

Definujeme si jednoho člověka jako čecha, druhého jako poláka.

Teď když na nich zavoláme metodu speak, vybere se správné tělo této funkce.

To není nic nového, to je jen ukázka toho, co je single dispatch.

<<OBRAZOVKA DOUBLE DISPATCHING person>>

Double dispatch znamená, že operace, která se má vykonat, závisí na jméně, na typu dvou objektu, na které se volá. 

Třídy person, následně čech a polak jsme upravili tak, aby spolu mohli komunikovat. 

Čekali bychom, že když třídě person přidáme 2 metody talkTo, která jedna bere za argument čecha a druhá poláka, tak že by nám to mohlo fungovat.

<< runner czech.talkTo(pole) nefunkcni >>

Jak ale vidíme, při volání czech.talkTo(pole) se polák nepřetypuje z Person na poláka.

Samozřejmě by se dalo v tomto případě přecastovat, ale to jen proto, že víme přesný typ. 

<< OBRAZOVKA PRIDAN talkTo(Person) do Person>>

Tak co se dá dělat je to, že dodefinujeme metodu talkTo, která bere jako parametr typ Person.

Protože čech i polák dědí od Person, musí se jim doimplementovat talkTo s parametrem person.

<< talkTo(Person p) v cechovi treba>>

Tím jsme se zbavili jednoho problému, ale hned nastal další. V tělech těchto metod opět nevíme, jaký je runtimeový typ tohoto persona, takže se těžko najde společná řeč.

Víme ale, díky single dispatch se dokáže určit runtime typ persona při volání funkce talkTo, tak toho využijeme. Už se i ví runtime typ čecha, takže další takový problém nenastane.

<< p.talkTo(this) >>

Tělo metody tedy vypadá následovně.

Vypadá to velmi podobně tomu, co známe z metody accept. 

Je to přesně to samé. Při voláni kódu element.accept(visitor) se nejdříve určí runtime typ elementu, a uvnitř těla accept se určí typ visitoru.

<< double dispatch vyřešeno>>

Stejně tedy v tomto středoevropském příkladě, určí se runtime typ objektu czech -- to je první dispatch -- a uvnitř metody talkTo se určí typ persona na poláka -- to je druhý dispatch.


<< SHRNUTÍ >>

Když si tedy shrneme visitor pattern tak víme, že máme dva hlavní stavební kameny, 

interface visitor, který má metody visit pro každou třídu. Jeho konkrétní implementace reprezentují vždy nějakou podobnou funkcionalitu pro tyto třídy

Druhý kámen je abstrakt element interface, který vynucuje přítomnost metody accept přijímající visitora. Co se třídě stane už je ve visitoru.

Visitor pattern používáme, když máme stálou strikturu tříd a k ní buď hodně operací, které nemusí být implementovány přímo ve třídě, protože s ní tolik nesouvisí. Nebo když plánujeme v postupu času přidávat další operace ke třídám.

Naopak se visitor pattern nevyplatí používat, když víme, že budeme často přidávat nové třídy.

<< PRIKLADY VYUZITI VISITORU>>

Visitor se dá využít třeba pro operace nad hierarchickými strukturami pro parsování hodnot a třeba jejich akumulaci uvnitř visitoru, dále také pro výpis jednotlivých od sebe odlišných prvků do textové nebo jiné podoby.

Nebo třeba v překladačích pro type checking jednotlivých objektů nebo jejich optimalizace. Jde o operace, které s jednotlivými objekty přímo nesouvisí.


<< VISITOR A SOUVISEJICI >>

Nakonec povím, jaká je souvislost visitoru a iterátoru. 

Oba dva mohou být použity na průchod strukturou objektů. 

Visitor se dá spíš využít na průchod složitější strukturou tak, že bude volat visit i na děti té struktury. Operace, která se má na tyto prvky použít je zanesena přímo ve visitoru.

Iterátor je zase spíš na průchod kolekcí stejného typu. Operace na objektech z této kolekce dělá naopak programátor.


Dále je visitor ještě ve vztahu s compositem.

Composite je stromová struktura která reprezentuje hierarchii jak primitivních tak komplexních objektů. Uživatel mezi nimi tak může ignorovat rozdíly. Chování jednotlivých elementů této struktury se dá oddělit do visitoru a odlehčit tak kód.























