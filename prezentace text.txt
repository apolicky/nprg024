Přečti tohle:

Visitor pattern je jeden z návrhových vzorů podle Gang of Four.

Hlavní motivace za visitor patternem je možnost objektům jednoduše přidávat nové funkce beze změny jejich struktury. Struktura třídy tedy zůstává a její nová funkcionalita je umístěna jinde.

Motivaci si ukážeme na následujícím příkladu.

Snažil jsem se vybrat téma, na které se visitor pattern dá použít a na kterém ho snad ještě nikdo neprezentoval.

<< OBRAZOVKA PATREON, DEFINICE A ODKAZ NA WIKI A PATREON>>

Dle wikipedie je Patreon platforma, která umožnuje fanouškům platit tvůrcům za jejich práci. Tvůrci jsou běžně vývojáři, youtubeři, moderátoří, a tak dál. 

Fanoušci tak dokáží zajistit tvůrcům stálý příjem a ti jim na oplátku dávají prémiový obsah, který pro ostatní není dostupný. Tvůrci také často dají fanouškům nebo také patronům volbu výše příspěvku, podle kterého se odvíjí množství dostupných výhod.

V tomto příkladě tedy půjde o interakci patronů a výhod, které dostávají.

<< OBRAZOVKA, KDE JE PATRON INTERFACE>>	

Mějme nějaký interface, který reprezentuje patrony.

V tomto příkladu dělím patrony do tří úrovní podle výše jejich příspěvků. Úroveň 0 odpovídá dvěma dolarům měsíčně, úroveň 1 pěti a úroveň 2 deseti. Umělec může mít připraveno úrovní kolik chce, často však počet úrovní nemění.

Jako metody patron interfacu jsou služby, které tvůrce patronům nabízí. Tento umělec jim třeba schránky na patreon účtu pošle záznam z koncertu nebo jim přidá nějaké featury do chatu na streamu - pro příklad nové emotikony. 

<< IMPLEMENTACE TIERU 0, TIER 1, TIER 2>>

Konkrétní implementace patrona už je třída, která dědí od třídy person všemožné lidské vlastnosti a navíc implementuje patron interface s patřičnými metodami.

U každé úrovně se ale liší, co každá metoda u objektu dělá. Jinými slovy jak vypadá daná výhoda pro danou úroveň.

<< OBRAZOVKA TIER 4 S IMPLEMENTOVANYMI METODAMI>>

Rozhodne-li se tvůrce, že přidá novou úroveň fanoušků, bude muset naprogramovat těla interfacových metod pro tu novou třídu.

<< OBRAZOVKA PRIDANE FUNKCE DO INTERFACE>>

Naopak když se rozhodne, že dá fanouškům navíc ještě další výhodu tedy funkci, a upraví patronský interface, bude muset zasáhnout do každé konkrétní patronské třídy. 

<< OBRAZOVKA CHYBÍ IMPLEMENTACE U VSECH DEDICICH>>

Nový kód je tak roztříštěný po různých souborech.

Je vidno, že přidání nové fanouškovské úrovně je tímto přístupem jednoduché. Stačí vytvořit novou třídu a implementovat patřičné metody.

Na druhou stranu přidaní další výhody znamená jak úpravu interfacu tak všech konkrétních tříd, které jsou touto změnou ovlivněny.

Navíc metody, které přidáváme dané třídě pro ní nemusí být vhodné z objektově orientovaného přístupu, protože s danou třídou nemusí nijak souviset.

<< OBRAZOVKA S DIAGRAMEM VISITOR PATTERNU >>

Visitor pattern je graficky zobrazen na tomto diagramu.

Nahoře vidíme visitor interface, který deklaruje metodu visit pro každý konkrétní element - podle našeho příkladu tedy pro každou úroveň podpory od fanouška. Všechny konkrétní implementace tohoto interfacu odpovídají jedné konkrétní funkcionalitě. 

Dole je acceptor interface - gang of four to označuje jako element nebo abstrakt element. Má metodu accept, která přijímá všechny třídy implementující visitor interface. Konkrétní implementace acceptor interfacu jistě mohou mít i jiné metody, v tomto není návrhový vzor nijak omezující. 

NEE		Tady vidíme, že konkrétní elementy implementují metodu accept, která přijímá visitor interface. Mohou mít i jiné metody, které jsou mezi elementy odlišné.

Každopádně vždy implementace metody accept obsahuje pouze jeden řádek, na kterém je volání funkce visit na předaném visitoru v s parametrem this. 

Samozřejmě se mohou předat i další parametry, ty by ale však musely být definovány už ve visitor interfacu a implementace konkrétních visitorů by je musely používat.

<< OBRAZOVKA, KDE JE TO ROZEPSANO >>

Na tomto slajdu je vidět, o čem jsem jsem mluvil.

Máme dva hlavní stavební kameny. Visitor interface, který deklaruje metodu visit pro každý konkrétní element, a interface pro prvky, které budou visitor využívat. Ty se poznají tak, že definují tělo metody accept.

Metoda accept přijímá jako argument implementaci třídy visitor, na kterém volá sobě příslušnou metodu visit

Metoda visit přijímá konkrétní prvek, respektivě referenci na něj. 

Navíc, jak jsem již zmiňoval, metoda visit může přijímat více než jeden argument a může mít i návratovou hodnotu. To vše záleží na tom, jak si programátor využití visitoru vymyslí. 

<< KDE VISITOR PATTERN VYUZIVAME>>

Visitor pattern se hodí použít tehdy, když máme:

	. program, kde mame hodne trid s ruznymi rozhranimi a chceme na nich provest operaci, ktera funguje jinak v zavislosti na druhu dane tridy
	. mnoho ruznych operaci, ktere spolu nijak nesouvisi a ktere maji byt provedeny na objektech programu. Toto by objekty mohlo zahltit zbytecnym kodem. VISITOR umoznuje oddelit operace do skupinek podle blizkosti do jednotlivych trid(konrk. visitoru)
	. tridy se malokdy meni ale casto se meni operace na teto strukture. Zmeny na prijimajicich tridach vyvolaji zmenu na vsech visiotrech. Kdyby se casto pridavaly nove tridy, je lepsi to mit uvnitr
	

<< CO TO ZNAMENA, KDYZ HO VYUZIJEME>>

	. easy nove operace
	. sjednoceni funkcnosti na jednom miste
	. rozdilne funkce po ruznych visitorech
	. novy concrete_element je tezke. 
	. predem si budeme muset vazne rozhodnout, jestli ho chceme nebo ne a jeslti uz je nase struktura pevna
	. visitor muze narozdil od iteratoru navstivit objekty s ruznymi predky,
	. public opertations s internim stavem, pac vse dela visitor
	. operace se daji dynamicky spojit s prvky pomoci visitoru a funkce accept


<< OBRAZOVKA PATREON VISITOR>>

Teď si ukážeme visitor pattern nasazený na příklad s patreonem.

Definoval jsem si dva interfacy, jeden se jmenuje patron interface, druhý patron visitor.

<< PATRON INTERFACE >>

Patron interface implementují opět 3 třídy, patroni nulté, první a druhé úrovně. Narozdíl od minulého příkladu má patron interface pouze jednu metodu a to accept, která přijímá implementace patron visitora.

<< KONKRETNI IMPLEMENTACE >>

<< PATRON VISITOR >>

Patron visitor je interface, který budou implementovat konkrétní visitory a definuje 3 metody visit, každou pro jednu patronskou úroveň. 

<< NOVY VISITOR IMPLEMENTACE meet & greet>>

Vytvoření nového visitoru je celkem straight forward. Vytvoříme třídu implementující patron visitor interface, přidáme implementaci všem metodám a je hotovo.

Tady vidíme meet & greet visitor

<< NOVY VISITOR IMPLEMENTACE live stream feature >>

Tady live stream feature visitor

<< RUN PROGRAM >>

Vytvoříme si program, kde máme nějaké patrony všech možných úrovní, vytvoříme si 

patron visitora. Teď to bude meet & greet visitor, a necháme ho navštívit všechny patrony.

<< OBRAZOVKA S VYPISEM >>

Tady vidíme výpis.

<< ZMENA VISITORA >>

<< JINY VYPIS>>

Visitor může se dělat i složitější úkony než jen vypisovat na konzoli.

Proto musí mít třídy, na které se visitor volá, nějaký způsob, jak o sobě visitoru předat informaci. Musí tedy mít public metody nebo fieldy, na které si visitor sáhne a dostane tak o třídách informace potřebné k provedení nějaké složitější operace.




<< OBRAZOVKA S DispatchingEM - single double definice>>

Většina jazyků, které běžně používáme podporují takzvaný single dispatch. Volaná funkce se vybere podle jména a typu objektu, na kterém se volá. 

Nejlépe to jde vidět na příkladu.

<< SINGLE DISPATCH obrazek s kodem, polak a cech>>

Tady máme třídu person, která je base třídou pro třídu čecha a poláka.

Definujeme si jednoho člověka jako čecha, druhého jako poláka.

Teď když na nich zavoláme metodu speak, vybere se správné tělo této funkce.

Operace, která se provede závisí na jméně volané funkce a na typu objektu, na kterém se volá. 


<< ZPET OBRAZOVKA S DISPATCHINGEM>>

Double dispatch znamená, že operace, která se má vykonat, závisí na jméně, na typu dvou objektu, na které se volá. 

NEEEE	Accept je zde double dispatch operace, jméno má jasné, závisí ještě na typu visitoru a na typu elementu. 

<< NOVĚ PŘIDANÁ static FUNKCE communicate>>

<< OBRAZOVKA czech.talkTo(polak) bez talkTo(person)>>

Čekali bychom, že když třídě person přidáme 2 metody talkTo, která jedna bere za argument čecha a druhá poláka, tak že by nám to mohlo fungovat.

Jak ale vidíme, při volání czech.talkTo(polak) se polak nepretypuje z Person na polaka.

Samozřejmě by se dalo v tomto případě přecastovat, ale to jen proto, že víme přesný typ.

<< OBRAZOVKA PRIDAN talkTo(Person) do Person>>

Správně bychom měli definovat metodu talkTo, která bere jako parametr Person. 

Protože čech i polák dědí od Person, musí se jim doimplementovat talkTo s personem.

<< talkTo(Person p) v cechovi treba>>

Tím jsme se zbavili jednoho problému, ale hned nastal další. V tělech těchto metod opět nevíme, jaký je runtimeový typ tohoto persona, takže se těžko najde společná řeč.

Víme ale, díky single dispatch se dokáže určit runtime typ persona při volání funkce talkTo, tak toho využijeme.

<< p.talkTo(this) >>

Metoda talkTo, která bere argument Person s tělem person.talkTo(this) vypadá velmi podobně tomu, co známe z metody accept. Je to přesně to samé. Při voláni kódu element.accept(visitor) se nejdříve určí runtime typ elementu, a uvnitř těla accept se určí typ visitoru.

Stejně tedy v tomto středoevropském příkladě, určí se runtime typ objektu czech -- to je první dispatch -- a uvnitř metody talkTo se určí typ persona na poláka -- to je druhý dispatch.


<< SHRNUTÍ >>

























